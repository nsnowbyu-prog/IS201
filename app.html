<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Nate Snow â€“ Game</title>

  <!-- Bootstrap CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />

  <style>
    body { background: #f6f7fb; }

    .wrap {
      max-width: 980px;
      margin: 0 auto;
      padding: 24px 16px 60px;
    }

    .game-card {
      border: 1px solid rgba(0,0,0,0.08);
      background: rgba(255,255,255,0.85);
      border-radius: 14px;
      padding: 18px;
      box-shadow: 0 10px 24px rgba(0,0,0,0.06);
    }

    canvas {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.08);
      background: linear-gradient(#dfe9ff, #ffffff);
      display: block;
    }

    .hint {
      color: #6c757d;
      font-size: 0.95rem;
    }
  </style>
</head>

<body>

  <!-- NAVBAR (note the ../ paths) -->
<nav class="navbar navbar-expand-lg sticky-top">
  <div class="container">
    <a class="navbar-brand fw-bold" href="../index.html">Nate Snow</a>

    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#mainNav">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse justify-content-end" id="mainNav">
      <ul class="navbar-nav gap-lg-2">
        <li class="nav-item"><a class="nav-link" href="index.html">Home</a></li>
        <li class="nav-item"><a class="nav-link" href="resume.html">Resume</a></li>
        <li class="nav-item"><a class="nav-link" href="travel.html">Traveling</a></li>
        <li class="nav-item"><a class="nav-link active" href="app.html">Game</a></li>
        <li class="nav-item"><a class="nav-link" href="index.html#tableau">Map</a></li>
        <li class="nav-item"><a class="nav-link" href="index.html#contact">Contact</a></li>
      </ul>
    </div>
  </div>
</nav>


  <div class="wrap">
    <h1 class="fw-bold mb-2">Runner Game</h1>
    <p class="hint mb-4">
      Press <b>Space</b> to jump. Avoid rocks &amp; trees. Your score increases while you survive.
    </p>

    <!-- GAME AREA -->
    <div class="game-card">
      <canvas id="game" width="900" height="320"></canvas>
      <div class="d-flex flex-wrap justify-content-between align-items-center mt-3">
        <button id="restartBtn" class="btn btn-dark btn-sm">Restart</button>
      </div>
    </div>
  </div>

  <!-- GAME SCRIPT -->
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const restartBtn = document.getElementById("restartBtn");

    // Scale for crispness on different displays
    function fitCanvas() {
      // Keep internal resolution consistent; canvas is styled width:100% via CSS
      // (No dynamic resizing needed unless you want it)
    }

    // Game state
    let running = true;
    let gameOver = false;

    let score = 0;
    let best = 0;

    // Player (stick figure)
    const player = {
      x: 80,
      y: 0,
      w: 22,
      h: 46,
      vy: 0,
      onGround: true
    };

    // World
    const groundY = 265;
    const gravity = 0.85;
    const jumpPower = -14.5;

    // Obstacles
    let obstacles = [];
    let spawnTimer = 0;

    // Speed
    let speed = 6.0;

    // Simple clouds for vibe
    const clouds = [
      { x: 100, y: 55, s: 0.6 },
      { x: 420, y: 80, s: 0.8 },
      { x: 720, y: 60, s: 0.7 }
    ];

    function resetGame() {
      running = true;
      gameOver = false;
      score = 0;
      speed = 6.0;
      obstacles = [];
      spawnTimer = 0;

      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    }

    function rand(min, max) {
      return Math.random() * (max - min) + min;
    }

    function spawnObstacle() {
      const type = Math.random() < 0.5 ? "rock" : "tree";
      const w = type === "rock" ? rand(26, 40) : rand(28, 40);
      const h = type === "rock" ? rand(18, 28) : rand(38, 62);

      obstacles.push({
        type,
        x: canvas.width + 20,
        y: groundY - h,
        w,
        h
      });
    }

    function drawBackground() {
      // sky already in canvas background gradient; draw extra details
      // clouds
      clouds.forEach(c => {
        c.x -= 0.6 * c.s;
        if (c.x < -120) c.x = canvas.width + 120;

        ctx.save();
        ctx.globalAlpha = 0.8;
        ctx.beginPath();
        ctx.ellipse(c.x, c.y, 42*c.s, 18*c.s, 0, 0, Math.PI*2);
        ctx.ellipse(c.x+28*c.s, c.y+4*c.s, 34*c.s, 14*c.s, 0, 0, Math.PI*2);
        ctx.ellipse(c.x-26*c.s, c.y+6*c.s, 30*c.s, 12*c.s, 0, 0, Math.PI*2);
        ctx.fillStyle = "#ffffff";
        ctx.fill();
        ctx.restore();
      });

      // ground
      ctx.fillStyle = "#0f172a";
      ctx.fillRect(0, groundY, canvas.width, 3);

      // subtle grass line
      ctx.fillStyle = "rgba(16,185,129,0.35)";
      ctx.fillRect(0, groundY+3, canvas.width, 2);
    }

    function drawStickFigure(p) {
      // head
      ctx.beginPath();
      ctx.arc(p.x + p.w/2, p.y + 10, 8, 0, Math.PI*2);
      ctx.fillStyle = "#111827";
      ctx.fill();

      // body
      ctx.strokeStyle = "#111827";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(p.x + p.w/2, p.y + 18);
      ctx.lineTo(p.x + p.w/2, p.y + 36);
      ctx.stroke();

      // arms
      ctx.beginPath();
      ctx.moveTo(p.x + p.w/2, p.y + 24);
      ctx.lineTo(p.x + 3, p.y + 30);
      ctx.moveTo(p.x + p.w/2, p.y + 24);
      ctx.lineTo(p.x + p.w - 3, p.y + 30);
      ctx.stroke();

      // legs
      ctx.beginPath();
      ctx.moveTo(p.x + p.w/2, p.y + 36);
      ctx.lineTo(p.x + 5, p.y + p.h);
      ctx.moveTo(p.x + p.w/2, p.y + 36);
      ctx.lineTo(p.x + p.w - 5, p.y + p.h);
      ctx.stroke();
    }

    function drawObstacle(o) {
      if (o.type === "rock") {
        // rock
        ctx.fillStyle = "#475569";
        ctx.beginPath();
        ctx.roundRect(o.x, o.y, o.w, o.h, 6);
        ctx.fill();

        ctx.fillStyle = "rgba(255,255,255,0.18)";
        ctx.beginPath();
        ctx.roundRect(o.x + o.w*0.15, o.y + o.h*0.2, o.w*0.35, o.h*0.28, 6);
        ctx.fill();
      } else {
        // tree (simple trunk + canopy)
        const trunkW = o.w * 0.35;
        const trunkH = o.h * 0.55;

        ctx.fillStyle = "#7c2d12";
        ctx.beginPath();
        ctx.roundRect(o.x + (o.w-trunkW)/2, o.y + (o.h-trunkH), trunkW, trunkH, 5);
        ctx.fill();

        ctx.fillStyle = "#166534";
        ctx.beginPath();
        ctx.arc(o.x + o.w/2, o.y + o.h*0.35, o.w*0.45, 0, Math.PI*2);
        ctx.arc(o.x + o.w*0.35, o.y + o.h*0.45, o.w*0.35, 0, Math.PI*2);
        ctx.arc(o.x + o.w*0.65, o.y + o.h*0.45, o.w*0.35, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function rectsOverlap(a, b) {
      return (
        a.x < b.x + b.w &&
        a.x + a.w > b.x &&
        a.y < b.y + b.h &&
        a.y + a.h > b.y
      );
    }

    function jump() {
      if (player.onGround && !gameOver) {
        player.vy = jumpPower;
        player.onGround = false;
      }
      if (gameOver) {
        resetGame();
      }
    }

    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") {
        e.preventDefault();
        jump();
      }
    });

    restartBtn.addEventListener("click", () => resetGame());

    // Polyfill for roundRect if needed
    if (!CanvasRenderingContext2D.prototype.roundRect) {
      CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
        r = Math.min(r, w/2, h/2);
        this.beginPath();
        this.moveTo(x+r, y);
        this.arcTo(x+w, y, x+w, y+h, r);
        this.arcTo(x+w, y+h, x, y+h, r);
        this.arcTo(x, y+h, x, y, r);
        this.arcTo(x, y, x+w, y, r);
        this.closePath();
        return this;
      };
    }

    function loop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawBackground();

      // Update player
      if (!gameOver) {
        player.vy += gravity;
        player.y += player.vy;

        if (player.y >= groundY - player.h) {
          player.y = groundY - player.h;
          player.vy = 0;
          player.onGround = true;
        }
      }

      // Spawn obstacles
      if (!gameOver) {
        spawnTimer--;
        if (spawnTimer <= 0) {
          spawnObstacle();
          spawnTimer = Math.floor(rand(55, 95));
        }
      }

      // Move obstacles + collisions
      obstacles.forEach(o => o.x -= speed);

      // Remove offscreen
      obstacles = obstacles.filter(o => o.x + o.w > -20);

      // Collision box for player
      const hitbox = {
        x: player.x + 2,
        y: player.y + 6,
        w: player.w - 4,
        h: player.h - 6
      };

      if (!gameOver) {
        for (const o of obstacles) {
          if (rectsOverlap(hitbox, o)) {
            gameOver = true;
            running = false;
            best = Math.max(best, Math.floor(score));
            break;
          }
        }
      }

      // Score
      if (!gameOver) {
        score += 0.15;        // score over time
        speed += 0.0009;      // gradually gets harder
      }

      // Draw obstacles
      obstacles.forEach(drawObstacle);

      // Draw player
      drawStickFigure(player);

      // UI
      ctx.fillStyle = "#111827";
      ctx.font = "20px Arial";
      ctx.fillText(`Score: ${Math.floor(score)}`, 20, 32);
      ctx.fillText(`Best: ${best}`, 20, 58);

      if (gameOver) {
        ctx.fillStyle = "rgba(17,24,39,0.85)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#ffffff";
        ctx.font = "42px Arial";
        ctx.fillText("Game Over", canvas.width/2 - 110, canvas.height/2 - 10);

        ctx.font = "18px Arial";
        ctx.fillText("Press Space or click Restart", canvas.width/2 - 125, canvas.height/2 + 28);
      }

      requestAnimationFrame(loop);
    }

    resetGame();
    loop();
  </script>

  <!-- Bootstrap JS -->
  <script
    src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
  ></script>
</body>
</html>

